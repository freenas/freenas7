*** dev/nfe/if_nfe.c	Fri Apr 17 16:07:02 2009
--- dev/nfe/if_nfe.c	Sun Apr 19 16:57:05 2009
***************
*** 123,129 ****
  static void nfe_set_macaddr(struct nfe_softc *, uint8_t *);
  static void nfe_dma_map_segs(void *, bus_dma_segment_t *, int, int);
  
! static void	nfe_enable_wol(struct nfe_softc *);
  static void	nfe_get_wolopts(struct nfe_softc *, struct if_wolopts *);
  static int	nfe_set_wolopts(struct nfe_softc *, struct if_wolopts *);
  
--- 123,129 ----
  static void nfe_set_macaddr(struct nfe_softc *, uint8_t *);
  static void nfe_dma_map_segs(void *, bus_dma_segment_t *, int, int);
  
! static void	nfe_enable_wol(device_t);
  static void	nfe_get_wolopts(struct nfe_softc *, struct if_wolopts *);
  static int	nfe_set_wolopts(struct nfe_softc *, struct if_wolopts *);
  
***************
*** 2992,2998 ****
  	NFE_WRITE(sc, NFE_STATUS, sc->mii_phyaddr << 24 | NFE_STATUS_MAGIC);
  
  	NFE_WRITE(sc, NFE_SETUP_R4, NFE_R4_MAGIC);
! 	NFE_WRITE(sc, NFE_WOL_CTL, NFE_WOL_MAGIC);
  
  	sc->rxtxctl &= ~NFE_RXTX_BIT2;
  	NFE_WRITE(sc, NFE_RXTX_CTL, sc->rxtxctl);
--- 2992,2999 ----
  	NFE_WRITE(sc, NFE_STATUS, sc->mii_phyaddr << 24 | NFE_STATUS_MAGIC);
  
  	NFE_WRITE(sc, NFE_SETUP_R4, NFE_R4_MAGIC);
! 	/* NFE_WRITE(sc, NFE_WOL_CTL, NFE_WOL_MAGIC); */
! 	NFE_WRITE(sc, NFE_WOL_CTL, 0);
  
  	sc->rxtxctl &= ~NFE_RXTX_BIT2;
  	NFE_WRITE(sc, NFE_RXTX_CTL, sc->rxtxctl);
***************
*** 3049,3062 ****
  	/* abort Tx */
  	NFE_WRITE(sc, NFE_TX_CTL, 0);
  
! 	if (sc->wol_events) {
! 	} else {
! 		/* disable Rx */
! 		NFE_WRITE(sc, NFE_RX_CTL, 0);
  
! 		/* disable interrupts */
! 		nfe_disable_intr(sc);
! 	}
  
  	sc->nfe_link = 0;
  
--- 3050,3060 ----
  	/* abort Tx */
  	NFE_WRITE(sc, NFE_TX_CTL, 0);
  
! 	/* disable Rx */
! 	NFE_WRITE(sc, NFE_RX_CTL, 0);
  
! 	/* disable interrupts */
! 	nfe_disable_intr(sc);
  
  	sc->nfe_link = 0;
  
***************
*** 3166,3178 ****
  	sc = device_get_softc(dev);
  
  	NFE_LOCK(sc);
- 	nfe_enable_wol(sc);
- 	NFE_UNLOCK(sc);
- 
- 	NFE_LOCK(sc);
  	ifp = sc->nfe_ifp;
  	nfe_stop(ifp);
  	/* nfe_reset(sc); */
  	NFE_UNLOCK(sc);
  }
  
--- 3164,3173 ----
  	sc = device_get_softc(dev);
  
  	NFE_LOCK(sc);
  	ifp = sc->nfe_ifp;
  	nfe_stop(ifp);
  	/* nfe_reset(sc); */
+ 	nfe_enable_wol(dev);
  	NFE_UNLOCK(sc);
  }
  
***************
*** 3266,3293 ****
   * Enable Wake On Lan.
   */
  static void
! nfe_enable_wol(struct nfe_softc *sc)
  {
! #if 1
! 	return;
! #else
! 	ADAPTER_POWERSTATE pstate = {0};
! 	PACKET_FILTER hwfilter;
  
  	if (sc->wol_events == 0)
  		return;
  
- 	hwfilter.ulFilterFlags = ACCEPT_ALL_PACKETS;
- 	sc->hwapi->pfnSetPacketFilter(sc->hwapi->pADCX, &hwfilter);
  	
  	if (sc->wol_events & IFWOL_WAKE_ON_MAGIC) {
! 		pstate.ulPowerFlags = POWER_STATE_D3;
! 		pstate.ulMagicPacketWakeUpFlags = POWER_STATE_ALL;
! 		pstate.ulLinkChangeWakeUpFlags = 0;
! 		pstate.ulPatternWakeUpFlags = 0;
! 		sc->hwapi->pfnSetPowerState(sc->hwapi->pADCX, &pstate);
  	}
- #endif
  }
  
  /*
--- 3261,3282 ----
   * Enable Wake On Lan.
   */
  static void
! nfe_enable_wol(device_t dev)
  {
! 	struct nfe_softc *sc;
! 
! 	sc = device_get_softc(dev);
  
  	if (sc->wol_events == 0)
  		return;
  
  	
  	if (sc->wol_events & IFWOL_WAKE_ON_MAGIC) {
! 		NFE_WRITE(sc, NFE_WOL_CTL, NFE_WOL_MAGIC);
! 		NFE_WRITE(sc, NFE_RXFILTER, NFE_PFF_ALWAYS|NFE_PFF_U2M);
! 		NFE_WRITE(sc, NFE_RX_CTL, NFE_RX_START);
! 		pci_set_powerstate(dev, PCI_POWERSTATE_D3);
  	}
  }
  
  /*
*** dev/nfe/if_nfereg.h	Fri Apr 17 16:07:02 2009
--- dev/nfe/if_nfereg.h	Sun Apr 19 14:16:25 2009
***************
*** 157,162 ****
--- 157,163 ----
  #define	NFE_PFF_LOOPBACK	(1 << 4)
  #define	NFE_PFF_U2M		(1 << 5)
  #define	NFE_PFF_PROMISC		(1 << 7)
+ #define NFE_PFF_ALWAYS		0x7F0000
  #define	NFE_CSUM_FEATURES	(CSUM_IP | CSUM_TCP | CSUM_UDP)
  
  /* default interrupt moderation timer of 128us */
*** dev/nve/if_nve.c	Fri Apr 17 16:07:03 2009
--- dev/nve/if_nve.c	Sun Apr 19 17:41:43 2009
***************
*** 757,769 ****
  
  	sc = device_get_softc(dev);
  
- 	NVE_LOCK(sc);
- 	nve_enable_wol(sc);
- 	NVE_UNLOCK(sc);
- 
  	/* Stop hardware activity */
  	NVE_LOCK(sc);
  	nve_stop(sc);
  	NVE_UNLOCK(sc);
  }
  
--- 757,766 ----
  
  	sc = device_get_softc(dev);
  
  	/* Stop hardware activity */
  	NVE_LOCK(sc);
  	nve_stop(sc);
+ 	nve_enable_wol(sc);
  	NVE_UNLOCK(sc);
  }
  
*** pci/if_sis.c	Fri Apr 17 16:07:03 2009
--- pci/if_sis.c	Sun Apr 19 18:30:09 2009
***************
*** 2159,2177 ****
  #endif /* DEVICE_POLLING */
  		break;
   	case SIOCGIFWOLSUPP:
!  		ifr->ifr_wolopts.ifwol_supported = NS_SUPPORTED_WOL_EVENTS;
!  		error = 0;
   		break;
   	case SIOCGIFWOLOPTS:
!  		SIS_LOCK(sc);
!  		sis_get_wolopts(sc, &ifr->ifr_wolopts);
!  		SIS_UNLOCK(sc);
!  		error = 0;
   		break;
   	case SIOCSIFWOLOPTS:
!  		SIS_LOCK(sc);
!  		error = sis_set_wolopts(sc, &ifr->ifr_wolopts);
!  		SIS_UNLOCK(sc);
    		break;
  	default:
  		error = ether_ioctl(ifp, command, data);
--- 2159,2190 ----
  #endif /* DEVICE_POLLING */
  		break;
   	case SIOCGIFWOLSUPP:
! 		if (sc->sis_type != SIS_TYPE_83815)
! 			error=-EINVAL;
! 		else {
!  			ifr->ifr_wolopts.ifwol_supported =
! 				NS_SUPPORTED_WOL_EVENTS;
!  			error = 0;
! 		}
   		break;
   	case SIOCGIFWOLOPTS:
! 		if (sc->sis_type != SIS_TYPE_83815)
! 			error=-EINVAL;
! 		else {
!  			SIS_LOCK(sc);
!  			sis_get_wolopts(sc, &ifr->ifr_wolopts);
!  			SIS_UNLOCK(sc);
!  			error = 0;
! 		}
   		break;
   	case SIOCSIFWOLOPTS:
! 		if (sc->sis_type != SIS_TYPE_83815)
! 			error=-EINVAL;
! 		else {
!  			SIS_LOCK(sc);
!  			error = sis_set_wolopts(sc, &ifr->ifr_wolopts);
!  			SIS_UNLOCK(sc);
! 		}
    		break;
  	default:
  		error = ether_ioctl(ifp, command, data);
*** pci/if_xl.c	Fri Apr 17 16:07:03 2009
--- pci/if_xl.c	Thu Apr 16 22:13:53 2009
***************
*** 3364,3369 ****
--- 3364,3370 ----
  	XL_LOCK(sc);
  	xl_reset(sc);
  	xl_stop(sc);
+ 	xl_enable_wol(dev);
  	XL_UNLOCK(sc);
  
  	return (0);
***************
*** 3378,3384 ****
  
  	XL_LOCK(sc);
  	xl_stop(sc);
- 	xl_enable_wol(dev);
  	XL_UNLOCK(sc);
  
  	return (0);
--- 3379,3384 ----
