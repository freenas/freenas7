#!/bin/sh
#
# Configure routing and miscellaneous network tunables
#
# $FreeBSD: src/etc/rc.d/routing,v 1.143 2007/05/02 15:49:30 mtm Exp $
#
# Modified by Volker Theile (votdev@gmx.de)
#

# PROVIDE: routing
# REQUIRE: netif
# KEYWORD: nojail

. /etc/rc.subr
. /etc/configxml.subr
. /etc/util.subr

name="routing"
start_cmd="routing_start"
stop_cmd="routing_stop"
extra_commands="options static mkconf"
static_cmd="static_start"
options_cmd="options_start"
mkconf_cmd="mkconf_cmd"

routing_start()
{
	mkconf_cmd
	static_start
	options_start
}

routing_stop()
{
	# Do not delete all routes, because there are set
	# various routes all over the code (e.g the default route in lan config.)
	#route -n flush

	for _route in `cat /var/db/routes.db`; do
		/sbin/route delete ${_route}
	done

	rm -f /var/db/routes.db > /dev/null 2>&1
}

mkconf_cmd()
{
	local _index _name _network _gateway _protocol

	# Clear /var/db/routes.db
	cat /dev/null > /var/db/routes.db

	_index=`configxml_get_count "//staticroutes/route"`
	_i=0
	while [ ${_index} -gt 0 ]
	do
		_name=`configxml_get "//staticroutes/route[position()=${_index}]/descr"`
		_network=`configxml_get "//staticroutes/route[position()=${_index}]/network"`
		_gateway=`configxml_get "//staticroutes/route[position()=${_index}]/gateway"`

		if is_validip inet6 ${_network}; then
			_protocol="-inet6"
		fi

		static_routes="${static_routes} ${_name}"
		eval route_${_name}="\"${_protocol} ${_network} ${_gateway}\""

		# Store route so it can be easily removed later (if necessary).
		# This is a stupid workaround, should be improved some day.
		echo ${_network} >> /var/db/routes.db

		_i=$(( ${_i} + 1 ))
		_index=$(( ${_index} - 1 ))
	done
}

static_start()
{
	case ${defaultrouter} in
	[Nn][Oo] | '')
		;;
	*)
		static_routes="default ${static_routes}"
		route_default="default ${defaultrouter}"
		;;
	esac

	# Setup static routes. This should be done before router discovery.
	#
	if [ -n "${static_routes}" ]; then
		for i in ${static_routes}; do
			eval route_args=\$route_${i}
			route add ${route_args}
		done
	fi
	# Now ATM static routes
	#
	if [ -n "${natm_static_routes}" ]; then
		for i in ${natm_static_routes}; do
			eval route_args=\$route_${i}
			atmconfig natm add ${route_args}
		done
	fi
}

options_start()
{
	echo -n 'Additional routing options:'
	case ${icmp_bmcastecho} in
	[Yy][Ee][Ss])
		echo -n ' broadcast ping responses=YES'
		sysctl net.inet.icmp.bmcastecho=1 >/dev/null
		;;
	esac

	case ${icmp_drop_redirect} in
	[Yy][Ee][Ss])
		echo -n ' ignore ICMP redirect=YES'
		sysctl net.inet.icmp.drop_redirect=1 >/dev/null
		;;
	esac

	case ${icmp_log_redirect} in
	[Yy][Ee][Ss])
		echo -n ' log ICMP redirect=YES'
		sysctl net.inet.icmp.log_redirect=1 >/dev/null
		;;
	esac

	case ${gateway_enable} in
	[Yy][Ee][Ss])
		echo -n ' IP gateway=YES'
		sysctl net.inet.ip.forwarding=1 >/dev/null
		;;
	esac

	case ${forward_sourceroute} in
	[Yy][Ee][Ss])
		echo -n ' do source routing=YES'
		sysctl net.inet.ip.sourceroute=1 >/dev/null
		;;
	esac

	case ${accept_sourceroute} in
	[Yy][Ee][Ss])
		echo -n ' accept source routing=YES'
		sysctl net.inet.ip.accept_sourceroute=1 >/dev/null
		;;
	esac

	case ${ipxgateway_enable} in
	[Yy][Ee][Ss])
		echo -n ' IPX gateway=YES'
		sysctl net.ipx.ipx.ipxforwarding=1 >/dev/null
		;;
	esac

	case ${arpproxy_all} in
	[Yy][Ee][Ss])
		echo -n ' ARP proxyall=YES'
		sysctl net.link.ether.inet.proxyall=1 >/dev/null
		;;
	esac

	echo '.'
}

load_rc_config $name
run_rc_command "$1"
